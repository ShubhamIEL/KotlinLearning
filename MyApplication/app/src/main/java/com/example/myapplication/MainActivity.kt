package com.example.myapplicationimport android.content.Intentimport android.os.Bundleimport android.util.Logimport android.widget.Buttonimport android.widget.EditTextimport android.widget.TextViewimport android.widget.Toastimport androidx.activity.enableEdgeToEdgeimport androidx.activity.viewModelsimport androidx.appcompat.app.AppCompatActivityimport androidx.core.view.ViewCompatimport androidx.core.view.WindowInsetsCompatimport androidx.databinding.DataBindingUtilimport androidx.recyclerview.widget.LinearLayoutManagerimport com.example.myapplication.databinding.ActivityMainBindingimport dagger.hilt.android.AndroidEntryPointimport kotlinx.coroutines.delay//class MainActivity : AppCompatActivity() {//    override fun onCreate(savedInstanceState: Bundle?) {//        super.onCreate(savedInstanceState)//        enableEdgeToEdge()//        setContentView(R.layout.activity_main)////        val myButton = findViewById<Button>(R.id.button1)////        myButton.setOnClickListener {////            val intent = Intent(this, SecondActivity::class.java)////            startActivity(intent)////        }//    }//}//class Car{//    var brand: String ="Gen"//    var speed: Int =0//    fun accelerate(){//        speed+=10e//        println("Accerating . Current speed is $speed km/h")//    }//}//fun main(){//    val myCar= Car()//    myCar.brand="Tesle"//    myCar.accelerate()//    myCar.accelerate()//}@AndroidEntryPointclass MainActivity:AppCompatActivity() {    private val profileViewModel: ProfileViewModel by viewModels()    private lateinit var binding: ActivityMainBinding    private lateinit var historyAdapter: HistoryAdapter    override fun onCreate(savedInstanceState: Bundle?) {        Log.d("MainActivity", "on Crete Called!!!")        super.onCreate(savedInstanceState)        // 1. Inflate the layout using DataBindingUtil        binding = DataBindingUtil.setContentView(this, R.layout.activity_main)        // 2. Set the lifecycle owner so DataBinding can observe LiveData        binding.lifecycleOwner = this        // 3. Assign the viewModel to the variable declared in the XML        binding.viewModel = profileViewModel//        binding = ActivityMainBinding.inflate(layoutInflater)//        setContentView(binding.root)        historyAdapter = HistoryAdapter()        binding.historyRecyclerView?.apply {            layoutManager = LinearLayoutManager(this@MainActivity)            adapter = historyAdapter        }        // --- The userName.observe block has been deleted --- /*       profileViewModel.userName.observe(this) { rawName ->            binding.progressBar?.hide() // Hide the progress bar once we get data            val displayText = when (rawName) {                "initial" -> getString(R.string.initial_user_name)                "ALEX (from Repository/IO thread)" -> getString(R.string.updated_user_name)                else -> getString(R.string.welcome_message, rawName)            }            binding.userName.text = displayText        } */        // (this is still needed for the RecyclerView)        // 3. Observe the history LiveData        profileViewModel.history.observe(this) { historyList ->            historyAdapter.submitList(historyList)        }        //Button listener        binding.updateNameButton.setOnClickListener {            val name = binding.nameInput.text.toString().trim()            // Requirement 2: Check if input is empty            if (name.isEmpty()) {                Toast.makeText(this, "Please enter a name", Toast.LENGTH_SHORT).show()                return@setOnClickListener // Stop further execution            }            // Requirement 3: Handle update with delay            binding.progressBar?.show()            profileViewModel.updateUserWithDelay(name)        }    }}//        binding.updateNameButton.setOnClickListener {//            binding.progressBar?.show() // Show the progress bar before starting the long task//            profileViewModel.fetchUpdatedUser()////            profileViewModel.fetchUpdatedUser()////            val name = binding.nameInput.text.toString()////////            // 2. Call the new function with the user's name////            profileViewModel.updateUserWithName(name)//////        }//        profileViewModel.fetchInitialUSer()//    }//}        //setContentView(R.layout.activity_main)//        binding.updateNameButton.setOnClickListener {//            val name = binding.nameInput.text.toString()//            profileViewModel.updateUSer(name)//        }//        profileViewModel.userName.observe(this){//            name -> binding.userName.text = name//        }//        profileViewModel.welcomeMsg.observe(this) { message ->//            binding.userName.text = message//        }//    }//}//        val userNameTextView = findViewById<TextView>(R.id.user_name)//        val nameInput = findViewById<EditText>(R.id.name_input)//        val updateButton = findViewById<Button>(R.id.update_name_button)//        val welcomeTextView = findViewById<TextView>(R.id.user_name)//        updateButton.setOnClickListener {//            val name = nameInput.text.toString()//            profileViewModel.updateUSer(name)//        }//        profileViewModel.welcomeMsg.observe(this){//            message -> welcomeTextView.text = message//        }//        profileViewModel.userName.observe(this) {//            newName->//            Log.d("MainActivity","UserName udpdated to: $newName")//            userNameTextView.text = newName//        }//        val myButton = findViewById<Button>(R.id.button1)//        myButton.setOnClickListener{////            profileViewModel.updateUSerAfterDelay()//        }//    }//}